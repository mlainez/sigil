@(critical-directive-tooling)

**ALL UTILITY SCRIPTS MUST BE WRITTEN IN AISL**

This is NON-NEGOTIABLE. Never use Python, Bash, or any other language.

Why:
1. Eating our own dog food - discovers language gaps immediately
2. Scripts become examples for LLMs
3. No external dependencies
4. Forces us to make AISL complete
5. If AISL can't do it, ADD IT TO AISL

Process when you need a script:
1. Check if AISL has the needed operations (regex, file I/O, string ops)
2. If missing, ADD IT TO AISL (extend VM, runtime, compiler)
3. Write the script in pure AISL
4. If you wrote Python/Bash, DELETE IT and rewrite in AISL

Examples of what should be AISL:
- convert_syntax.aisl ✓ (converts test syntax)
- test runners ✓ (already in AISL)
- build scripts → TODO: rewrite in AISL
- code generators → TODO: write in AISL
- documentation generators → TODO: write in AISL

**If you catch yourself writing Python, STOP and use AISL instead**

@(critical-directive-machine-readable-first)

**ALWAYS CONSULT AND UPDATE MACHINE-READABLE FORMATS FIRST**

When working on AISL, the order of consultation is:
1. FIRST: .aisl.grammar (syntax reference, 42 lines, ~400 tokens)
2. SECOND: .aisl.meta (project context, compressed s-expr)
3. THIRD: .aisl.analysis (design decisions, this file)
4. LAST: AGENTS.md and other markdown (human docs, 8000+ tokens)

Why this order:
- Token efficiency: 20x fewer tokens in machine formats
- Faster context loading
- More structured information
- Easier to parse programmatically
- Updated more frequently with discoveries

**CRITICAL**: After ANY change to language behavior or discovering usage patterns:
1. Update .aisl.grammar @(note ...) section FIRST
2. Update .aisl.analysis with @(tag) entries SECOND
3. Only then update AGENTS.md if humans need it
4. Never duplicate info - keep it in ONE canonical place

Machine format rules:
- .aisl.grammar: Syntax rules, ops, types, critical notes (s-expr format)
- .aisl.analysis: Design decisions, directives, discovered issues (tagged sections)
- .aisl.meta: Project metadata, context (compressed s-expr)

Markdown format rules:
- AGENTS.md: Human-readable guide for LLMs generating AISL
- LANGUAGE_SPEC.md: Complete language reference for humans
- README.md: Project overview for humans

**NEVER put information only in markdown** - always in machine-readable first, then optionally in markdown if humans need it.

@(critical-directive-documentation)

**DOCUMENTATION MUST ALWAYS BE UP TO DATE AND MINIMAL**

Three rules:

1. **Always Update Docs After Code Changes**
   - Changed syntax? Update AGENTS.md, LANGUAGE_SPEC.md, .aisl.grammar
   - Added feature? Document in all relevant places
   - Changed behavior? Update examples
   - NEVER commit code without updating docs
   - Check examples/ folder - make sure examples work

2. **Only Keep User-Facing Documentation**
   - KEEP: Language reference, API docs, user guides
   - REMOVE: Implementation plans, thinking process, session notes
   - Store internal notes in .aisl.* files (compressed format)
   - Delete: *-PLAN.md, *-SUMMARY.md, *-ANALYSIS.md (human-readable thinking)
   - Keep: .aisl.meta, .aisl.grammar, .aisl.analysis (machine-readable context)

3. **NEVER Create Implementation Status Files**
   - NO: IMPLEMENTATION-STATUS.md, ROADMAP.md, TODO.md, CHANGES.md
   - NO: Any markdown files tracking progress, plans, or internal state
   - YES: Put ALL relevant context in .aisl.* files (machine-readable)
   - YES: Only keep README.md, AGENTS.md, LANGUAGE_SPEC.md, AISL-CORE.md, AISL-AGENT.md
   - If you need to track something, add it to .aisl.analysis with @(tag)

Process:
1. After ANY code change, update docs immediately
2. Before committing, verify examples/ folder works
3. Remove any human-readable "thinking" documents
4. Keep only language description for users
5. NEVER generate implementation tracking markdown files

@(fix-bugs-directive-2026-02-07)

**NEW DIRECTIVE: Fix bugs in the language when discovered during use**

Process:
1. When writing AISL code, if you hit a bug or limitation
2. FIX IT immediately in the language/compiler/VM
3. Don't work around it - fix the root cause
4. Update documentation with the fix
5. Add test case for the bug

This directive ensures:
- AISL improves through actual use
- No accumulated workarounds
- Language becomes more robust over time
- Real usage drives development

Examples:
- Found: type keywords as var names cause crashes → FIX: add parser check
- Found: parser rejects valid syntax → FIX: update parser rules
- Found: missing stdlib function → FIX: add to VM runtime

**NEVER leave bugs unfixed** - they compound over time

@(principle one-way-only)

**There should be EXACTLY ONE way to do each thing**

Not "both syntaxes work", not "old is deprecated" - ONE canonical form, period.

Examples:
- Function params: `a int b int` (NOT `((a int) (b int))`)
- Module keyword: `module` (NOT `mod` - conflicts with modulo)
- Explicit call: `(call add a b)` (NOT implicit `(add a b)`)
- Explicit types: `(set x int 42)` (NOT inferred)

**LLMs want EXPLICIT not FLEXIBLE**

Maximum explicitness = minimum ambiguity = LLM-friendly

@(runtime-errors-2026-02-07)

**DISCOVERED: Reserved type keywords used as variable names cause silent failures**

Issue found during LLM generation testing:
```
(set json string "{\"model\":\"codellama\"}")  ; json is TYPE keyword
(call print json)                              ; Prints "0" not string!
```

Root cause:
- Lexer tokenizes 'json' as TOK_TYPE_JSON not TOK_IDENTIFIER
- Parser accepts it (no error check)
- VM treats as type confusion
- Silent runtime failure (prints wrong value, crashes on string ops)

**CRITICAL BUG**: Parser should reject type keywords as variable names

Reserved keywords that CANNOT be variable names:
- int, float, string, bool
- json, array, map, result, option, regex

Error should be: "Cannot use type keyword 'json' as variable name"

Workaround for LLMs:
- Use json_str, json_data, json_obj instead of json
- Use arr, data_array instead of array
- Use hashmap, value_map instead of map

**ACTION NEEDED**: Add parser check to reject type keywords as identifiers

@(core-ir-syntax-confusion-2026-02-07)

**DISCOVERED: Core IR constructs are NOT function calls**

Common LLM mistake during testing:
```
(call label my_label)   ; WRONG - parse error
(call goto my_label)    ; WRONG - parse error
(call ifnot flag skip)  ; WRONG - parse error
```

Correct syntax:
```
(label my_label)        ; Core IR construct
(goto my_label)         ; Core IR construct
(ifnot flag skip)       ; Core IR construct
```

Explanation:
- label/goto/ifnot are Core IR primitives, not functions
- They have special parsing rules
- They do NOT use (call ...) syntax
- Parser recognizes them as statement types directly

When to use:
- label: Mark jump target
- goto: Unconditional jump to label
- ifnot: Jump to label if condition is false

Prefer Agent constructs when possible:
- while/loop instead of label/goto
- if instead of ifnot (when if is available)
- break/continue for loop control

**FOR LLMs**: Use label/goto/ifnot only for complex control flow that can't be expressed with while/loop/break/continue

@(multiple-ret-restriction-2026-02-07)

**DISCOVERED: Cannot have multiple ret statements after labels in simple functions**

Pattern that FAILS:
```
(fn example flag bool -> string
  (ifnot flag return_b)
  (ret "A")              ; First ret
  (label return_b)       ; Parse error - code after ret
  (ret "B"))
```

Parser rejects this because:
- ret is supposed to end function execution
- Code after ret is unreachable in simple analysis
- label after ret violates this assumption

**WORKAROUND**: Use result variable with single ret:
```
(fn example flag bool -> string
  (set result string "B")   ; Default value
  (ifnot flag skip)         ; Jump if condition false
  (set result string "A")   ; Override if not jumped
  (label skip)
  (ret result))             ; Single ret at end
```

Pattern:
1. Initialize result variable with default/fallback value
2. Use ifnot to skip override logic
3. Set result to primary value if not skipped
4. Place label after override
5. Single ret result at end

**FOR LLMs**: Always use result variable + single ret pattern for conditional returns

@(if-statement-multi-stmt-bug-2026-02-08)

**CRITICAL BUG: Parser treats ALL statements after if condition as then-branch**

**STATUS**: Known bug, workaround documented

Problem: Parser at compiler/c/src/parser.c lines 681-706 parses ALL remaining statements after an if condition as part of the then-branch, making it impossible to have proper if-then-else logic.

Example of bug:
```aisl
(if condition
  (call print "then 1")
  (set x int 1)        ; ❌ Always executes regardless of condition!
  (call print "else")) ; ❌ Always executes regardless of condition!
```

What happens: The parser treats everything after the condition as a single sequence in the then-branch. There's no way to specify an else-branch.

**WORKAROUND - Result Variable Pattern**:
```aisl
; Store condition result in a variable
(set success bool (call compile_test file))

; Then-branch: only executes if true
(if success
  (call print "✓ passed")
  (set passed int (call add passed 1)))

; Else-branch: only executes if false
(if (call not success)
  (call print "✗ failed"))
```

Why this works: Each `if` is independent, and we control which one executes by using `(call not ...)`.

Alternative: Use result variable with multiple actions
```aisl
; Set a default value
(set message string "failed")

; Override if condition is true
(if (call gt x 5)
  (set message string "success")
  (set x int 0))

; message is now either "failed" or "success"
(call print message)
```

**FOR LLMs**: ALWAYS use the result variable pattern for conditional logic with separate then/else branches.

**Status**: The documented syntax `(if condition then_expr else_expr)` from AISL-AGENT.md is NOT YET IMPLEMENTED in the v3 parser. Use workarounds above.

@(module-naming-restriction-2026-02-07)

**DISCOVERED: Cannot name modules same as type keywords**

Problem: "json" is a TYPE keyword (TYPE_JSON, TOK_TYPE_JSON)
- Parser tokenizes "json" as type, not identifier
- Error: "Module '' not found" (empty string due to parse confusion)
- Solution: Named module "json_utils" instead

**Rule**: NEVER name modules same as type keywords:
- int, float, string, bool, json, array, map, result, option, regex

Use descriptive names instead:
- json_utils (NOT json)
- array_helpers (NOT array)
- string_utils (NOT string)
- map_utils (NOT map)

@(string-ret-from-if-bug-2026-02-07)

**DISCOVERED: Returning string literals from if blocks doesn't work**

Pattern that FAILS:
```aisl
(fn test x int -> string
  (set check bool (call lt x 0))
  (if check
    (ret "negative"))
  (ret "positive"))
```

Symptom: Always returns second value, if body never executes properly
Affects: String literals only (int returns work fine)

**WORKAROUND - Result variable pattern**:
```aisl
(fn test x int -> string
  (set result string "positive")
  (if check
    (set result string "negative"))
  (ret result))
```

**FOR LLMs**: NEVER return string literals directly from if blocks. Always use result variable pattern.

@(missing-closing-paren-error-2026-02-07)

**DISCOVERED: Missing closing parenthesis causes confusing error**

Problem: Missing closing ) for module causes "Module '' not found" error
- Not "parse error" or "unexpected EOF"
- Difficult to diagnose

**Rule**: Always verify module has matching closing paren

Example:
```aisl
(module my_module
  (fn func1 ...)
  (fn func2 ...))
; Closing paren here ^
```

@(process-exec-bug-fixed-2026-02-08)

**FIXED: process_exec was terminating VM**

Problem: OP_PROCESS_EXEC used execvp() which replaces entire process
- VM would terminate on first call
- Test runners couldn't execute multiple tests

Root cause: execvp() replaces current process image
- No return after execvp() succeeds
- VM ceased to exist

Fix implemented (vm.c:2509-2527):
- Changed from execvp() to fork+exec+wait pattern
- Uses existing process_spawn() and process_wait()
- VM continues running after command completes
- Returns exit code properly

Status: ✅ FIXED - All test runners now work correctly
