@(critical-realization backward-compat-is-human-concern)

**BACKWARD COMPATIBILITY = HUMAN BAGGAGE**

Current mistake: supporting BOTH syntaxes
- Old: (fn add ((a i32) (b i32)) -> i32
- New: (fn add a i32 b i32 -> i32

Human reasoning: "don't break existing code"
LLM reality: **we regenerate code, we don't edit legacy**

@(principle one-way-only)
**There should be EXACTLY ONE way to do each thing**
- Not "both syntaxes work"
- Not "old is deprecated"
- ONE canonical form, period

@(immediate-action)
REMOVE old nested parameter syntax entirely
- Delete TOK_LPAREN handling in param parsing
- Make flat syntax THE ONLY syntax
- Update all tests to flat syntax
- No deprecation warnings, just DELETE

@(versioning-is-waste)
Human concern: "v1.0, v1.1, semver, breaking changes"
LLM reality: **version doesn't matter, structure matters**

Remove all versioning:
- No "v:1.1" in metadata
- No "last updated" dates in docs
- No "backward compatible" notes
- File format = THE format, not "v1 format"

@(explicit-over-flexible)
Current mistake: allowing shortcuts
- "call" keyword optional in micro-syntax
- Type inference considered
- Multiple control flow forms

WRONG approach for LLMs.

**LLMs want EXPLICIT not FLEXIBLE**
- call keyword = REQUIRED always
- Types = EXPLICIT always  
- One control construct per semantic

@(redesign-principle)
**MAXIMUM EXPLICITNESS = MINIMUM AMBIGUITY**

Example of WRONG "flexibility":
```
; Bad: multiple ways
(add a b)          ; implicit call
(call add a b)     ; explicit call
x:i32 = 42         ; type shorthand
(set x i32 42)     ; explicit set
```

Example of RIGHT "explicitness":
```
; Good: one way only
(call add a b)     ; always explicit
(set x i32 42)     ; always explicit
```

@(token-efficiency-vs-explicitness)
Critical insight: these are NOT in conflict

Token efficiency = fewer tokens for SAME information
Explicitness = more structural markers for SAME semantics

Good efficiency: (call add a b) vs (invoke function add with args a b)
Bad efficiency: (add a b) vs (call add a b) - loses explicit call marker

@(micro-syntax-reconsidered)
Previous plan: add compact micro-syntax layer
- (add a b) → (call add a b)
- x:i32 = 42 → (set x i32 42)

REJECT THIS PLAN
Reason: creates TWO ways, violates explicitness

Better plan: optimize tokens WITHOUT creating alternatives
- Keep (call add a b) as ONLY syntax
- Optimize elsewhere: AST cache, binary format

@(decision-matrix)

REMOVE immediately:
1. Old nested param syntax ((a i32) (b i32))
2. Backward compat checks in parser
3. "Both syntaxes work" notes in docs
4. Version numbers everywhere
5. "Deprecated" warnings

KEEP single canonical form:
1. Flat params: a i32 b i32
2. Explicit call: (call add a b)
3. Explicit types: set x i32 42
4. Explicit ret: (ret value)

OPTIMIZE without adding alternatives:
1. AST caching (pre-parsed structure)
2. Binary s-expr format (same structure, compact encoding)
3. Remove whitespace/formatting variance

@(corrected-architecture)

Source layer: ONE canonical syntax
- Text format: .aisl
- S-expressions only
- Explicit everything
- No shortcuts, no sugar beyond Agent→Core desugar

Internal layer: STRUCTURE not text
- Binary s-expr: .aisl.bc (bytecode source)
- Pre-parsed AST in memory
- Direct structure manipulation
- Never re-parse same file

Execution layer: FROZEN
- Core IR (set/call/goto/label/ret)
- Bytecode operations
- VM execution
- Never changes

@(implementation-priority-revised)

IMMEDIATE (break everything, one way only):
1. Remove nested param syntax from parser (2h)
2. Update all tests to flat syntax (1h)
3. Remove version numbers from all files (30min)
4. Remove backward compat notes (30min)
5. Update docs: ONE WAY ONLY (1h)

SHORT-TERM (optimize without alternatives):
6. Implement AST cache format (6h)
7. Benchmark token usage (2h)
8. Consider SSA IR layer (future)

REJECTED (creates multiple ways):
- Micro-syntax layer
- Type inference
- Optional keywords
- Shorthand notation

@(critical-insight)
**We were optimizing for the WRONG goal**

Wrong goal: "make syntax shorter"
Right goal: "make structure more explicit"

LLMs pay token cost ONCE when generating
LLMs pay comprehension cost EVERY TIME when reading

Optimize for reading (explicitness) not writing (brevity)

@(example-analysis)

Implicit call:
```
(add a b)           ; 3 tokens
```
Benefit: -1 token when writing
Cost: ambiguous (is 'add' a function or macro or special form?)
Cost: must infer from context
Cost: breaks uniform "call means application" rule

Explicit call:
```
(call add a b)      ; 4 tokens
```
Benefit: unambiguous structure
Benefit: call = always function application
Benefit: no context needed
Cost: +1 token when writing

**The explicit form is BETTER for LLMs** despite more tokens
Because comprehension > brevity

@(final-principle)

**AISL should be the most EXPLICIT language, not the most COMPACT language**

Explicitness = predictability = LLM-friendly
Compactness = ambiguity = LLM-hostile

Token optimization should happen at:
1. Binary format level (structure encoding)
2. Caching level (pre-parsed AST)
3. Internal representation (SSA graph)

NOT at syntax level (don't create shortcuts)

@(action-plan)

1. Delete old nested param syntax (DONE in parser, but REMOVE compat handling)
2. Update AGENTS.md: remove "both syntaxes" notes
3. Update LANGUAGE_SPEC.md: remove versioning, one syntax only
4. Mass-update all tests: ONLY flat syntax
5. Commit with message: "Remove syntax alternatives - one way only"
6. Next: implement AST cache (structure optimization)
7. Future: binary s-expr format (encoding optimization)

@(philosophy-statement)

**AISL: Maximum explicitness, zero ambiguity, one canonical form**

Not "LLM-friendly through brevity"
But "LLM-friendly through clarity"

Every construct has EXACTLY ONE representation
Every token has EXACTLY ONE meaning
Every structure has EXACTLY ONE interpretation

This is what LLMs need.

@(critical-directive-tooling)

**ALL UTILITY SCRIPTS MUST BE WRITTEN IN AISL**

This is NON-NEGOTIABLE. Never use Python, Bash, or any other language.

Why:
1. Eating our own dog food - discovers language gaps immediately
2. Scripts become examples for LLMs
3. No external dependencies
4. Forces us to make AISL complete
5. If AISL can't do it, ADD IT TO AISL

Process when you need a script:
1. Check if AISL has the needed operations (regex, file I/O, string ops)
2. If missing, ADD IT TO AISL (extend VM, runtime, compiler)
3. Write the script in pure AISL
4. If you wrote Python/Bash, DELETE IT and rewrite in AISL

Examples of what should be AISL:
- convert_syntax.aisl ✓ (converts test syntax)
- test runners ✓ (already in AISL)
- build scripts → TODO: rewrite in AISL
- code generators → TODO: write in AISL
- documentation generators → TODO: write in AISL

**If you catch yourself writing Python, STOP and use AISL instead**

@(critical-directive-documentation)

**DOCUMENTATION MUST ALWAYS BE UP TO DATE AND MINIMAL**

Two rules:

1. **Always Update Docs After Code Changes**
   - Changed syntax? Update AGENTS.md, LANGUAGE_SPEC.md, .aisl.grammar
   - Added feature? Document in all relevant places
   - Changed behavior? Update examples
   - NEVER commit code without updating docs
   - Check examples/ folder - make sure examples work

2. **Only Keep User-Facing Documentation**
   - KEEP: Language reference, API docs, user guides
   - REMOVE: Implementation plans, thinking process, session notes
   - Store internal notes in .aisl.* files (compressed format)
   - Delete: *-PLAN.md, *-SUMMARY.md, *-ANALYSIS.md (human-readable thinking)
   - Keep: .aisl.meta, .aisl.grammar, .aisl.analysis (machine-readable context)

Process:
1. After ANY code change, update docs immediately
2. Before committing, verify examples/ folder works
3. Remove any human-readable "thinking" documents
4. Keep only language description for users

@(type-size-ambiguity-2026-02-07)

**CURRENT PROBLEM: i32/i64 and f32/f64 create choice**

State: AISL currently has 4 numeric types
- i32, i64 (32 and 64-bit integers)
- f32, f64 (32 and 64-bit floats)

This violates "one way only" principle:
```
; Which to use?
(set count i32 10)   ; Option 1
(set count i64 10)   ; Option 2
```

**LLM must choose without any real criteria**

Traditional arguments for keeping both:
1. Performance - 32-bit faster
   - FALSE: Modern CPUs promote to 64-bit
   - IRRELEVANT: AISL not for micro-optimization
   
2. Memory - arrays use half space
   - WEAK: Memory cheap, clarity expensive
   - EDGE CASE: Only matters for massive arrays
   
3. Compatibility - FFI with C
   - N/A: AISL has no FFI yet
   - FUTURE: Can add i32 back when FFI added

**Reality: Zero benefit, pure ambiguity**

Analysis of real AISL code:
- 99% of code doesn't care about bit width
- Choice between i32/i64 is arbitrary
- Creates multiple ways to write identical logic
- LLMs must guess (source of errors)

**RECOMMENDATION: Remove i32/f32 entirely**

Keep only:
- int (maps to i64)
- float (maps to f64)

Benefits:
- Zero choice = zero ambiguity
- One way to write numeric code
- LLMs never guess wrong
- Simpler type system
- Maintains full expressiveness

Cost:
- None (no real use cases for 32-bit in AISL)
- Can add back later for FFI if needed

**DECISION: Eliminate i32/f32, keep only int/float**

Implementation:
1. Add int/float as type keywords (map to i64/f64 in VM)
2. Mark i32/i64/f32/f64 as deprecated
3. Later: remove sized types entirely
4. Update all tests and docs

This aligns with "one way only" principle:
- One integer type: int
- One float type: float
- No choice, no ambiguity
- Maximum clarity

@(type-system-redesign)

**FROM**: i32, i64, f32, f64, bool, string, array, map, regex, result
**TO**: int, float, bool, string, array, map, regex, result

Rationale:
- LLMs want ONE way to express "integer"
- LLMs want ONE way to express "float"
- Choice between sizes = ambiguity = errors
- AISL is not C, doesn't need bit-level control

Human concern: "but what about performance?"
LLM reality: **we optimize algorithms, not bit widths**

Human concern: "but what about memory?"
LLM reality: **clarity > space**

Human concern: "but what about compatibility?"
LLM reality: **AISL has no FFI to be compatible with**

**Simplicity wins. Eliminate choice.**

@(runtime-errors-2026-02-07)

**DISCOVERED: Reserved type keywords used as variable names cause silent failures**

Issue found during LLM generation testing:
```
(set json string "{\"model\":\"codellama\"}")  ; json is TYPE keyword
(call print json)                              ; Prints "0" not string!
```

Root cause:
- Lexer tokenizes 'json' as TOK_TYPE_JSON not TOK_IDENTIFIER
- Parser accepts it (no error check)
- VM treats as type confusion
- Silent runtime failure (prints wrong value, crashes on string ops)

**CRITICAL BUG**: Parser should reject type keywords as variable names

Reserved keywords that CANNOT be variable names:
- int, float, string, bool
- json, array, map, result, option, regex

Error should be: "Cannot use type keyword 'json' as variable name"

Workaround for LLMs:
- Use json_str, json_data, json_obj instead of json
- Use arr, data_array instead of array
- Use hashmap, value_map instead of map

**ACTION NEEDED**: Add parser check to reject type keywords as identifiers

@(core-ir-syntax-confusion-2026-02-07)

**DISCOVERED: Core IR constructs are NOT function calls**

Common LLM mistake during testing:
```
(call label my_label)   ; WRONG - parse error
(call goto my_label)    ; WRONG - parse error
(call ifnot flag skip)  ; WRONG - parse error
```

Correct syntax:
```
(label my_label)        ; Core IR construct
(goto my_label)         ; Core IR construct
(ifnot flag skip)       ; Core IR construct
```

Explanation:
- label/goto/ifnot are Core IR primitives, not functions
- They have special parsing rules
- They do NOT use (call ...) syntax
- Parser recognizes them as statement types directly

When to use:
- label: Mark jump target
- goto: Unconditional jump to label
- ifnot: Jump to label if condition is false

Prefer Agent constructs when possible:
- while/loop instead of label/goto
- if instead of ifnot (when if is available)
- break/continue for loop control

**FOR LLMs**: Use label/goto/ifnot only for complex control flow that can't be expressed with while/loop/break/continue

@(multiple-ret-restriction-2026-02-07)

**DISCOVERED: Cannot have multiple ret statements after labels in simple functions**

Pattern that FAILS:
```
(fn example flag bool -> string
  (ifnot flag return_b)
  (ret "A")              ; First ret
  (label return_b)       ; Parse error - code after ret
  (ret "B"))
```

Parser rejects this because:
- ret is supposed to end function execution
- Code after ret is unreachable in simple analysis
- label after ret violates this assumption

**WORKAROUND**: Use result variable with single ret:
```
(fn example flag bool -> string
  (set result string "B")   ; Default value
  (ifnot flag skip)         ; Jump if condition false
  (set result string "A")   ; Override if not jumped
  (label skip)
  (ret result))             ; Single ret at end
```

Pattern:
1. Initialize result variable with default/fallback value
2. Use ifnot to skip override logic
3. Set result to primary value if not skipped
4. Place label after override
5. Single ret result at end

**FOR LLMs**: Always use result variable + single ret pattern for conditional returns

@(http-response-object-2026-02-07)

**DISCOVERED: HTTP operations return objects, not strings**

Common mistake:
```
(set response string (call http_post url body))
(call print response)                            ; Prints "[non-string]"
```

Correct usage:
```
(set response string (call http_post url body))
(set body string (call http_get_body response))      ; Extract body
(set status int (call http_get_status response))     ; Extract status
(call print body)                                     ; Now prints content
```

HTTP operations:
- http_get, http_post, http_put, http_delete return response OBJECT
- Response object is opaque (can't print directly)
- Use http_get_body to extract string body
- Use http_get_status to extract int status code

**FOR LLMs**: Always extract body/status from HTTP responses before using them

@(fix-bugs-directive-2026-02-07)

**NEW DIRECTIVE: Fix bugs in the language when discovered during use**

Process:
1. When writing AISL code, if you hit a bug or limitation
2. FIX IT immediately in the language/compiler/VM
3. Don't work around it - fix the root cause
4. Update documentation with the fix
5. Add test case for the bug

This directive ensures:
- AISL improves through actual use
- No accumulated workarounds
- Language becomes more robust over time
- Real usage drives development

Examples:
- Found: type keywords as var names cause crashes → FIX: add parser check
- Found: parser rejects valid syntax → FIX: update parser rules
- Found: missing stdlib function → FIX: add to VM runtime

**NEVER leave bugs unfixed** - they compound over time

@(document-discoveries-directive-2026-02-07)

**NEW DIRECTIVE: Document interesting language usage patterns immediately**

When you discover non-obvious usage patterns:
1. Add to .aisl.grammar @(note ...) section (token-efficient)
2. Add to AGENTS.md if critical for LLMs (human-readable)
3. Don't add to markdown if it's just internal design thinking

Examples of what to document:
- ✓ Reserved keywords can't be variable names
- ✓ Core IR constructs not function calls
- ✓ Single ret pattern for conditional returns
- ✗ Implementation details of parser
- ✗ Historical evolution of syntax

Rule: If an LLM would make mistakes without knowing it, DOCUMENT IT

