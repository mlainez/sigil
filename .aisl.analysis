@(critical-directive-tooling)

**ALL UTILITY SCRIPTS MUST BE WRITTEN IN AISL**

This is NON-NEGOTIABLE. Never use Python, Bash, or any other language.

Why:
1. Eating our own dog food - discovers language gaps immediately
2. Scripts become examples for LLMs
3. No external dependencies
4. Forces us to make AISL complete
5. If AISL can't do it, ADD IT TO AISL

Process when you need a script:
1. Check stdlib/ for available modules (string_utils, json_utils, conversion, etc.)
2. If missing, ADD IT TO AISL (extend interpreter runtime)
3. Write the script in pure AISL
4. If you wrote Python/Bash, DELETE IT and rewrite in AISL

Examples of what should be AISL:
- convert_syntax.aisl (converts test syntax)
- test runners (already in AISL)
- build scripts -> TODO: rewrite in AISL
- code generators -> TODO: write in AISL
- documentation generators -> TODO: write in AISL

**If you catch yourself writing Python, STOP and use AISL instead**

@(always-check-stdlib)

**ALWAYS CHECK stdlib/ FOR AVAILABLE MODULES BEFORE IMPLEMENTING**

Available modules:

stdlib/ (17 pure AISL implementations):
- core/: string_utils, conversion, array_utils, math, math_extended, filesystem, network, text_utils, validation
- data/: json_utils
- net/: http
- pattern/: regex
- sys/: process
- db/: sqlite
- crypto/: base64, hash, hmac

Note: Many string ops are now BOTH builtins AND in stdlib:
- Builtins (always available): string_contains, string_trim, string_replace, string_starts_with, string_ends_with
- Stdlib string_utils: split, to_upper, to_lower (plus AISL implementations of the above)

Process:
1. List stdlib/ directory to see available modules
2. Check module manifest (.aisl.manifest) for function signatures
3. Import module with: (import <module_name>)
4. Use available functions

Example:
```
(import conversion)
(set num_str string (string_from_int 42))
```

**NEVER implement something that exists in stdlib/**

@(critical-directive-machine-readable-first)

**ALWAYS CONSULT AND UPDATE MACHINE-READABLE FORMATS FIRST**

When working on AISL, the order of consultation is:
1. FIRST: .aisl.grammar (syntax reference, ~196 lines, ~1600 tokens)
2. SECOND: .aisl.analysis (design decisions, this file)
3. LAST: AGENTS.md and other markdown (human docs, 8000+ tokens)

Why this order:
- Token efficiency: 20x fewer tokens in machine formats
- Faster context loading
- More structured information
- Easier to parse programmatically
- Updated more frequently with discoveries

**CRITICAL**: After ANY change to language behavior or discovering usage patterns:
1. Update .aisl.grammar @(note ...) section FIRST
2. Update .aisl.analysis with @(tag) entries SECOND
3. Only then update AGENTS.md if humans need it
4. Never duplicate info - keep it in ONE canonical place

Machine format rules:
- .aisl.grammar: Syntax rules, ops, types, critical notes (s-expr format)
- .aisl.analysis: Design decisions, directives, discovered issues (tagged sections)

Markdown format rules:
- AGENTS.md: Human-readable guide for LLMs generating AISL
- LANGUAGE_SPEC.md: Complete language reference for humans
- README.md: Project overview for humans

**NEVER put information only in markdown** - always in machine-readable first, then optionally in markdown if humans need it.

@(critical-directive-documentation)

**DOCUMENTATION MUST ALWAYS BE UP TO DATE AND MINIMAL**

Three rules:

1. **Always Update Docs After Code Changes**
   - Changed syntax? Update AGENTS.md, LANGUAGE_SPEC.md, .aisl.grammar
   - Added feature? Document in all relevant places
   - Changed behavior? Update examples
   - NEVER commit code without updating docs
   - Check examples/ folder - make sure examples work

2. **Only Keep User-Facing Documentation**
   - KEEP: Language reference, API docs, user guides
   - REMOVE: Implementation plans, thinking process, session notes
   - Store internal notes in .aisl.* files (compressed format)
   - Delete: *-PLAN.md, *-SUMMARY.md, *-ANALYSIS.md (human-readable thinking)
   - Keep: .aisl.grammar, .aisl.analysis (machine-readable context)

3. **NEVER Create Implementation Status Files**
   - NO: IMPLEMENTATION-STATUS.md, ROADMAP.md, TODO.md, CHANGES.md
   - NO: Any markdown files tracking progress, plans, or internal state
   - YES: Put ALL relevant context in .aisl.* files (machine-readable)
   - YES: Only keep README.md, AGENTS.md, LANGUAGE_SPEC.md, AISL-CORE.md, AISL-AGENT.md
   - If you need to track something, add it to .aisl.analysis with @(tag)

Process:
1. After ANY code change, update docs immediately
2. Before committing, verify examples/ folder works
3. Remove any human-readable "thinking" documents
4. Keep only language description for users
5. NEVER generate implementation tracking markdown files

@(fix-bugs-directive)

**DIRECTIVE: Fix bugs in the language when discovered during use**

Process:
1. When writing AISL code, if you hit a bug or limitation
2. FIX IT immediately in the interpreter
3. Don't work around it - fix the root cause
4. Update documentation with the fix
5. Add test case for the bug

This directive ensures:
- AISL improves through actual use
- No accumulated workarounds
- Language becomes more robust over time
- Real usage drives development

Examples:
- Found: type keywords as var names cause crashes -> FIX: add parser check
- Found: parser rejects valid syntax -> FIX: update parser rules
- Found: missing stdlib function -> FIX: add to interpreter runtime

**NEVER leave bugs unfixed** - they compound over time

@(principle one-way-only)

**There should be EXACTLY ONE way to do each thing**

Not "both syntaxes work", not "old is deprecated" - ONE canonical form, period.

Examples:
- Function params: `a int b int` (NOT `((a int) (b int))`)
- Module keyword: `module` (NOT `mod` - conflicts with modulo)
- Explicit call: `(add a b)` (direct function call syntax)
- Explicit types: `(set x int 42)` (NOT inferred)

**LLMs want EXPLICIT not FLEXIBLE**

Maximum explicitness = minimum ambiguity = LLM-friendly

@(reserved-type-keywords)

**Type keywords cannot be used as variable names**

Reserved keywords that CANNOT be variable names:
- int, float, string, bool
- json, array, map
- process, socket, file
- channel, future, unit

Recommended variable names:
- json_str, json_data, json_obj instead of json
- arr, data_array instead of array
- hashmap, value_map instead of map

Parser error message:
"Cannot use type keyword 'X' as variable name. Use a descriptive name instead (e.g., 'X_data', 'X_value')"

@(core-ir-constructs)

**Core IR constructs are NOT function calls**

Core IR primitives (use directly, no call keyword):
- `(label name)` - Mark jump target
- `(goto target)` - Unconditional jump to label
- `(ifnot condition target)` - Jump to label if condition is false

These are statement types in the parser, not function calls. Do NOT use `(call label ...)` etc.

Prefer Agent constructs when possible:
- while/loop instead of label/goto
- if instead of ifnot
- break/continue for loop control

Use label/goto/ifnot only for complex control flow that can't be expressed with while/loop/break/continue.

@(multiple-ret-pattern)

**Use result variable pattern for conditional returns**

Instead of:
```
(fn example flag bool -> string
  (ifnot flag return_b)
  (ret "A")
  (label return_b)
  (ret "B"))
```

Use:
```
(fn example flag bool -> string
  (set result string "B")
  (ifnot flag skip)
  (set result string "A")
  (label skip)
  (ret result))
```

Pattern:
1. Initialize result variable with default value
2. Use ifnot to skip override logic
3. Single ret at end

@(if-else-support)

**If-else now works with (else ...) block syntax**

Syntax:
```
(if condition
  then-statements...
  (else
    else-statements...))
```

The `(else ...)` block is optional. When present, it must be the last element in the if body.

Example:
```
(fn classify x int -> string
  (set result string "zero")
  (if (gt x 0)
    (set result string "positive")
    (else
      (if (lt x 0)
        (set result string "negative"))))
  (ret result))
```

Note: Multiple statements work correctly in both then and else branches.

@(return-string-from-if)

**Returning string literals from if blocks works correctly with if-else**

With if-else support, you can now use:
```
(fn test x int -> string
  (if (lt x 0)
    (ret "negative")
    (else
      (ret "positive"))))
```

The result variable pattern is still valid but no longer required:
```
(fn test x int -> string
  (set result string "positive")
  (if (lt x 0)
    (set result string "negative"))
  (ret result))
```

@(module-naming)

**Never name modules same as type keywords**

Type keywords: int, float, string, bool, json, array, map, option, regex

Use descriptive names:
- json_utils (NOT json)
- array_helpers (NOT array)
- string_utils (NOT string)
- map_utils (NOT map)

Module named with type keyword causes: "Module '' not found" error

@(missing-module-paren)

**Modules must end with closing parenthesis**

```
(module my_module
  (fn func1 ...)
  (fn func2 ...))
```

Missing closing ) causes confusing "Module '' not found" error

@(interpreter-architecture)

**OCaml tree-walking interpreter - no bytecode, no compilation step**

Implementation: interpreter/ directory (OCaml 5.2.1, dune build system)

Components:
- lexer.ml - Tokenizes S-expressions
- parser.ml - Recursive descent parser, produces AST
- types.ml - Type kind definitions
- ast.ml - AST node types
- interpreter.ml - ~2520 lines: eval, eval_call (all builtins), eval_block, test framework, import system, WebSocket helpers, special forms (And, Or, ForEach, Cond), try/catch, structural equality, deep copy, BigDecimal, LitArray, LitMap
- vm.ml - Entry point: reads file, tokenizes, parses, executes

Build: cd interpreter && eval $(opam env) && dune build
Run: ./interpreter/_build/default/vm.exe program.aisl

Libraries: unix, str, ssl (OpenSSL bindings)

No separate desugaring pass - interpreter handles Agent constructs (while, loop, if, if-else, for-each, break, continue, and, or) directly in eval_block.

@(for-each-loop)

**for-each loop iterates array elements or map keys**

Syntax: `(for-each var type collection body...)`

- For arrays: binds each element to `var` with declared `type`
- For maps: binds each key (as string) to `var`
- Supports `break` and `continue`
- Validates element type against declared type at runtime

Example:
```
(set nums array (array_new))
(array_push nums 1)
(array_push nums 2)
(array_push nums 3)
(set total int 0)
(for-each val int nums
  (set total int (add total val)))
```

@(short-circuit-and-or)

**and/or are AST-level special forms, NOT function calls**

Key design: `and`/`or` are parsed as `And`/`Or` AST nodes and evaluated in `eval`, not `eval_call`.
This is because `eval_call` pre-evaluates all arguments (`List.map (eval env) args`), which defeats short-circuit evaluation.

- `(and e1 e2)`: Returns false immediately if e1 is false; e2 is never evaluated
- `(or e1 e2)`: Returns true immediately if e1 is true; e2 is never evaluated
- `not` remains in `eval_call` (single arg, no short-circuit needed)

Verified: `(and false (gt (div 1 0) 0))` does NOT divide by zero.

@(string-format-find)

**string_format and string_find builtins**

`string_format`: Takes template with `{}` placeholders plus additional args.
- Replaces `{}` sequentially with string_of_value of each arg
- Extra `{}` without args left as-is
- Example: `(string_format "Hello, {}! You are {} years old." name age)`

`string_find`: Returns index of first occurrence of needle in haystack.
- Returns -1 if not found
- Returns 0 for empty needle
- Example: `(string_find "hello world" "world")` -> 6

@(dynamic-stdlib-resolution)

**Stdlib paths resolved dynamically at runtime**

The interpreter walks up from the source file directory to find the project root containing `stdlib/`.
Falls back to executable directory, then current working directory.
This eliminates hardcoded absolute paths that break on different machines.

@(try-catch-error-handling)

**Try/catch for recoverable error handling**

Syntax: `(try body... (catch var type handler...))`

How it works:
- Evaluates body statements sequentially
- If a RuntimeError is raised (division by zero, array bounds, etc.), jumps to catch block
- The error message (string) is bound to the catch variable
- Catch variable type must be `string`
- After catch block completes, execution continues after the try/catch

Implementation details (interpreter.ml ~line 864):
- Uses OCaml's `try...with` to catch `RuntimeError` exceptions
- Body statements are evaluated in order; first RuntimeError triggers catch
- Catch block gets a fresh binding for the error variable
- Try/catch blocks can be nested - inner catch handles inner errors

Parser details (parser.ml `parse_try` function, ~lines 186-220):
- Scans body expressions until it finds `(catch ...)` as the last form
- Catch clause must be the last element inside try
- Validates catch has variable name and type

Examples:
```
(try
  (set result int (div 10 0))
  (catch err string
    (print err)))

(try
  (set val int (array_get arr 999))
  (catch err string
    (set val int -1)))
```

Use cases:
- Catching division by zero without guard checks
- Handling array/map access errors gracefully
- Wrapping file I/O that might fail
- Any operation that panics with RuntimeError

Note: This does NOT replace guard checks for simple cases. Use `(if (eq b 0) ...)` for known-risky operations. Use try/catch when the error source is less predictable.

@(no-closures-design)

**Functions deliberately do NOT capture their defining scope**

When a user-defined function is called (interpreter.ml ~lines 2207-2213), only `VFunction` values from the parent environment are copied into the new function's environment. Regular variables (VInt, VString, VArray, etc.) are NOT copied.

This means:
- Functions can call other functions (VFunction values are available)
- Functions CANNOT access variables from the scope where they were defined
- All data a function operates on MUST be passed explicitly as parameters
- No hidden state, no implicit captures, no closures

Why this is intentional:
1. LLM explicitness: Function behavior is fully determined by its signature + body
2. No hidden dependencies: Reading the function signature tells you ALL its inputs
3. Predictable: No spooky action at a distance from captured variables
4. Debuggable: No need to trace what was captured when the function was created

Implementation:
```ocaml
(* Only copy VFunction values into new env *)
Hashtbl.iter (fun k v ->
  match v with
  | VFunction _ -> Hashtbl.replace new_env k v
  | _ -> ()
) parent_env
```

Implications for LLM code generation:
- ALWAYS pass data as function parameters
- NEVER rely on outer scope variables being visible
- Functions are pure transforms: params in, return value out
- Use module-level functions for shared behavior, not nested scopes

@(cond-construct)

**Flat multi-branch conditional: (cond)**

Syntax:
```
(cond
  (condition1 body1...)
  (condition2 body2...)
  (true fallback-body...))
```

Evaluates conditions in order, executes the body of the first matching branch. Returns VUnit if no condition matches. Use `true` as the last condition for a default/else branch.

Implementation: `Cond of (expr * expr list) list` AST node, evaluated in `eval` after `If`.

Example:
```
(fn classify_number n int -> string
  (set result string "unknown")
  (cond
    ((gt n 0) (set result string "positive"))
    ((lt n 0) (set result string "negative"))
    (true (set result string "zero")))
  (ret result))
```

When to use `cond` vs nested `if-else`:
- Use `cond` when you have 3+ branches — flatter, more readable
- Use `if-else` for simple binary conditions
- `cond` is syntactic sugar — no performance difference

@(array-map-literal-syntax)

**Array and map literal syntax**

Array literals: `[element1 element2 element3]`
Map literals: `{"key1" value1 "key2" value2}`

Implementation: `LitArray of expr list` and `LitMap of (expr * expr) list` AST nodes.
Lexer: `LBracket | RBracket | LBrace | RBrace` tokens for `[]{}`.

Examples:
```
(set nums array [1 2 3 4 5])
(set names array ["Alice" "Bob" "Charlie"])
(set config map {"host" "localhost" "port" 8080})
(set empty_arr array [])
(set empty_map map {})
```

Rules:
- Array elements can be any expression (evaluated left-to-right)
- Map keys must evaluate to strings; values can be any expression
- Map keys are stored in insertion order
- These desugar to VArray/VMap values (same runtime representation as array_new/map_new)

@(floor-ceil-round-builtins)

**floor, ceil, round builtins (float -> int)**

Three rounding builtins for float-to-int conversion:
- `(floor x)` — rounds toward negative infinity → VInt
- `(ceil x)` — rounds toward positive infinity → VInt
- `(round x)` — rounds to nearest integer (banker's rounding) → VInt

All take VFloat, return VInt (Int64).

Examples:
```
(set x float 3.7)
(floor x)   ; -> 3
(ceil x)    ; -> 4
(round x)   ; -> 4

(set y float -2.3)
(floor y)   ; -> -3
(ceil y)    ; -> -2
(round y)   ; -> -2
```

@(string-builtins-promoted)

**String operations promoted to builtins (no import needed)**

Five string operations are now builtins in addition to being available via `(import string_utils)`:

- `(string_starts_with text prefix)` → bool — checks if text starts with prefix
- `(string_ends_with text suffix)` → bool — checks if text ends with suffix
- `(string_contains haystack needle)` → bool — checks if haystack contains needle
- `(string_trim text)` → string — trims spaces, tabs, newlines, carriage returns from both ends
- `(string_replace text old new)` → string — replaces ALL occurrences of old with new

These work without any import. The stdlib `string_utils` module still provides AISL implementations of these plus `split`, `to_upper`, `to_lower`.

@(argv-builtins)

**Command-line argument builtins**

- `(argv)` → VArray of strings — returns command-line arguments (skips executable and filename)
- `(argv_count)` → VInt — returns count of extra arguments

Example:
```
(fn main -> int
  (set args array (argv))
  (set count int (argv_count))
  (print "Got arguments: ")
  (print count)
  (ret 0))
```

Running: `./vm.exe program.aisl foo bar` → args = ["foo", "bar"], count = 2
