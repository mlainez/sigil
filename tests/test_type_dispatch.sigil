(module type_dispatch
  (fn add_two_numbers x int y int -> int
    (ret (add x y)))
  
  (test-spec add_two_numbers
    (case "basic int addition via polymorphic add"
      (input 10 20)
      (expect 30))
    (case "zero addition"
      (input 0 42)
      (expect 42))
    (case "negative numbers"
      (input -5 15)
      (expect 10)))
  
  (fn subtract_numbers x int y int -> int
    (ret (sub x y)))
  
  (test-spec subtract_numbers
    (case "basic int subtraction via polymorphic sub"
      (input 20 10)
      (expect 10))
    (case "negative result"
      (input 5 10)
      (expect -5)))
  
  (fn multiply_numbers x int y int -> int
    (ret (mul x y)))
  
  (test-spec multiply_numbers
    (case "basic int multiplication via polymorphic mul"
      (input 5 6)
      (expect 30))
    (case "multiply by zero"
      (input 42 0)
      (expect 0)))
  
  (meta-note "Tests type-directed dispatch for polymorphic operations (add, sub, mul)
              LLMs can write 'add' instead of 'add' and compiler resolves based on argument types"))
