(mod test_process
  (fn create_args_array ((size i32)) -> array
    (ret (call ArrayNew size)))
  
  (test-spec create_args_array
    (case "create array of size 1"
      (mock (ArrayNew 1) "array_1")
      (input 1)
      (expect "array_1")))
  
  (fn set_array_element ((arr array) (idx i32) (val string)) -> array
    (call ArraySet arr idx val)
    (ret arr))
  
  (test-spec set_array_element
    (case "set first element to 1"
      (mock (ArraySet "array_1" 0 "1") "array_1")
      (input "array_1" 0 "1")
      (expect "array_1")))
  
  (fn spawn_process ((cmd string) (args array)) -> string
    (ret (call process_spawn cmd args)))
  
  (test-spec spawn_process
    (case "spawn sleep process"
      (mock (process_spawn "sleep" "array_1") "proc_1")
      (input "sleep" "array_1")
      (expect "proc_1"))
    (case "spawn echo process"
      (mock (process_spawn "echo" "array_2") "proc_2")
      (input "echo" "array_2")
      (expect "proc_2")))
  
  (fn wait_for_process ((proc string)) -> i32
    (ret (call process_wait proc)))
  
  (test-spec wait_for_process
    (case "wait for sleep process exit code 0"
      (mock (process_wait "proc_1") 0)
      (input "proc_1")
      (expect 0))
    (case "wait for echo process exit code 0"
      (mock (process_wait "proc_2") 0)
      (input "proc_2")
      (expect 0)))
  
  (fn read_process_output ((proc string)) -> string
    (ret (call process_read proc)))
  
  (test-spec read_process_output
    (case "read echo output"
      (mock (process_read "proc_2") "Hello from AISL!\n")
      (input "proc_2")
      (expect "Hello from AISL!\n")))
  
  (meta-note "Tests process spawning operations atomically - create args, spawn, wait, read output with mocked process calls"))
