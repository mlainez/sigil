#!/usr/bin/env python3
"""
AISL to Java Translator

Translates AISL intermediate representation to Java code.
Usage: aisl-to-java input.aisl output.java
"""

import sys
import re
from pathlib import Path

# Type mapping: AISL -> Java
TYPE_MAP = {
    'i8': 'byte', 'i16': 'short', 'i32': 'int', 'i64': 'long',
    'u8': 'short', 'u16': 'int', 'u32': 'long', 'u64': 'long',
    'f32': 'float', 'f64': 'double',
    'string': 'String',
    'bool': 'boolean',
    'unit': 'void',
    'array': 'ArrayList',
    'map': 'HashMap',
    'json': 'Map',
}

# Operation mapping: AISL builtins -> Java
OP_MAP = {
    'op_add_i32': '+',
    'op_sub_i32': '-',
    'op_mul_i32': '*',
    'op_div_i32': '/',
    'op_mod_i32': '%',
    
    'op_add_i64': '+',
    'op_sub_i64': '-',
    'op_mul_i64': '*',
    'op_div_i64': '/',
    
    'op_add_f32': '+',
    'op_sub_f32': '-',
    'op_mul_f32': '*',
    'op_div_f32': '/',
    
    'op_add_f64': '+',
    'op_sub_f64': '-',
    'op_mul_f64': '*',
    'op_div_f64': '/',
    
    'op_eq_i32': '==',
    'op_ne_i32': '!=',
    'op_lt_i32': '<',
    'op_gt_i32': '>',
    'op_le_i32': '<=',
    'op_ge_i32': '>=',
    
    'str_concat': '+',
    'str_length': 'length',
    
    'io_print_i32': 'System.out.println',
    'io_print_i64': 'System.out.println',
    'io_print_f32': 'System.out.println',
    'io_print_f64': 'System.out.println',
    'io_print_str': 'System.out.println',
    'io_print_bool': 'System.out.println',
    
    'array_new': 'ArrayList',
    'array_push': 'add',
    'array_get': 'get',
    'array_len': 'size',
    
    'map_new': 'HashMap',
    'map_set': 'put',
    'map_get': 'get',
}

class JavaTranslator:
    def __init__(self):
        self.indent_level = 0
        self.output = []
        self.class_name = "AislModule"
        self.imports = set()
        
    def indent(self):
        return '    ' * self.indent_level
        
    def emit(self, code):
        self.output.append(self.indent() + code)
        
    def translate_type(self, aisl_type):
        """Convert AISL type to Java type"""
        return TYPE_MAP.get(aisl_type, 'Object')
        
    def translate_call(self, func_name, args):
        """Translate function call"""
        # Check if it's a builtin operation
        if func_name in OP_MAP:
            op = OP_MAP[func_name]
            
            # Binary operators
            if op in ['+', '-', '*', '/', '%', '==', '!=', '<', '>', '<=', '>=']:
                if len(args) == 2:
                    return f"({args[0]} {op} {args[1]})"
                    
            # Unary/special functions
            if op == 'length' and len(args) == 1:
                return f"{args[0]}.length()"
            if op == 'System.out.println':
                return f"System.out.println({', '.join(args)})"
            if op == 'ArrayList' and len(args) == 0:
                self.imports.add('java.util.ArrayList')
                return "new ArrayList<>()"
            if op == 'HashMap' and len(args) == 0:
                self.imports.add('java.util.HashMap')
                return "new HashMap<>()"
            if op == 'add' and len(args) == 2:
                return f"{args[0]}.add({args[1]})"
            if op == 'get' and len(args) == 2:
                return f"{args[0]}.get({args[1]})"
            if op == 'put' and len(args) == 3:
                return f"{args[0]}.put({args[1]}, {args[2]})"
            if op == 'size' and len(args) == 1:
                return f"{args[0]}.size()"
                
        # Regular function call
        return f"{func_name}({', '.join(args)})"
        
    def parse_sexpr(self, code):
        """Very simple S-expression parser"""
        # This is a simplified version - in production, use a proper parser
        tokens = re.findall(r'\(|\)|[^\s()]+', code)
        
        def parse_tokens(i):
            if i >= len(tokens):
                return None, i
                
            if tokens[i] == '(':
                result = []
                i += 1
                while i < len(tokens) and tokens[i] != ')':
                    item, i = parse_tokens(i)
                    if item is not None:
                        result.append(item)
                return result, i + 1
            else:
                return tokens[i], i + 1
                
        ast, _ = parse_tokens(0)
        return ast
        
    def translate_expr(self, expr):
        """Translate an expression"""
        if isinstance(expr, str):
            # Literal or variable
            if expr.startswith('"') and expr.endswith('"'):
                return expr  # String literal
            if expr.isdigit() or (expr[0] == '-' and expr[1:].isdigit()):
                return expr  # Number literal
            if expr == 'true':
                return 'true'
            if expr == 'false':
                return 'false'
            return expr  # Variable name
            
        if isinstance(expr, list) and len(expr) > 0:
            op = expr[0]
            
            if op == 'call':
                func = expr[1] if len(expr) > 1 else 'unknown'
                args = [self.translate_expr(e) for e in expr[2:]]
                if isinstance(func, list):
                    func = self.translate_expr(func)
                result = self.translate_call(func, args)
                # Check if it's a statement
                if ('System.out.println' in result or '.add(' in result or 
                    '.put(' in result):
                    self.emit(result + ';')
                    return None
                return result
                
            if op == 'set':
                var_name = expr[1]
                var_type = self.translate_type(expr[2])
                value = self.translate_expr(expr[3]) if len(expr) > 3 else 'null'
                self.emit(f"{var_type} {var_name} = {value};")
                return None
                
            if op == 'ret':
                if len(expr) > 1:
                    value = self.translate_expr(expr[1])
                    self.emit(f"return {value};")
                else:
                    self.emit("return;")
                return None
                
            if op == 'if':
                cond = self.translate_expr(expr[1])
                self.emit(f"if ({cond}) {{")
                self.indent_level += 1
                then_expr = expr[2]
                self.translate_expr(then_expr)
                self.indent_level -= 1
                if len(expr) > 3:
                    self.emit("} else {")
                    self.indent_level += 1
                    else_expr = expr[3]
                    self.translate_expr(else_expr)
                    self.indent_level -= 1
                self.emit("}")
                return None
                
        return "null"
        
    def translate_function(self, func_def):
        """Translate a function definition"""
        # (fn name ((param1 type1) (param2 type2)) -> return_type body)
        func_name = func_def[1]
        params = func_def[2] if len(func_def) > 2 else []
        return_type = 'void'
        body_start = 3
        
        # Check for return type (-> type)
        if len(func_def) > body_start and func_def[body_start] == '->':
            return_type = func_def[body_start + 1]
            body_start = body_start + 2
            
        # Build parameter list
        java_params = []
        if isinstance(params, list):
            for param in params:
                if isinstance(param, list) and len(param) >= 2:
                    param_name = param[0]
                    param_type = self.translate_type(param[1])
                    java_params.append(f"{param_type} {param_name}")
                    
        # Generate function signature
        java_return = self.translate_type(return_type)
        params_str = ', '.join(java_params)
        self.emit(f"public static {java_return} {func_name}({params_str}) {{")
        self.indent_level += 1
        
        # Translate body
        for i in range(body_start, len(func_def)):
            self.translate_expr(func_def[i])
            
        self.indent_level -= 1
        self.emit("}")
        self.emit("")  # Blank line after function
        
    def translate_module(self, module):
        """Translate a module"""
        # Extract module name
        if len(module) > 1:
            self.class_name = module[1].capitalize()
            
        # Collect all function definitions first
        functions = []
        for i in range(2, len(module)):
            item = module[i]
            if isinstance(item, list) and len(item) > 0:
                if item[0] == 'fn':
                    functions.append(item)
        
        # Translate all functions to determine imports
        temp_output = self.output
        self.output = []
        for func in functions:
            self.translate_function(func)
        function_code = '\n'.join(self.output)
        self.output = temp_output
        
        # Add header with imports
        self.emit("// Generated by AISL to Java translator")
        if self.imports:
            for imp in sorted(self.imports):
                self.emit(f"import {imp};")
            self.emit("")
        
        self.emit(f"public class {self.class_name} {{")
        self.indent_level += 1
        self.emit("")
        
        # Add the functions
        for line in function_code.split('\n'):
            if line:
                self.output.append(line)
            else:
                self.emit("")
        
        self.indent_level -= 1            
        self.emit("}")
                    
        return '\n'.join(self.output)

def main():
    if len(sys.argv) != 3:
        print("Usage: aisl-to-java input.aisl output.java")
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    # Read AISL code
    try:
        with open(input_file, 'r') as f:
            aisl_code = f.read()
    except Exception as e:
        print(f"Error reading {input_file}: {e}")
        sys.exit(1)
        
    # Parse and translate
    translator = JavaTranslator()
    ast = translator.parse_sexpr(aisl_code)
    
    if ast and isinstance(ast, list) and ast[0] == 'mod':
        java_code = translator.translate_module(ast)
        
        # Write Java code
        try:
            with open(output_file, 'w') as f:
                f.write(java_code)
            print(f"Translated {input_file} -> {output_file}")
        except Exception as e:
            print(f"Error writing {output_file}: {e}")
            sys.exit(1)
    else:
        print("Error: Invalid AISL module format")
        sys.exit(1)

if __name__ == '__main__':
    main()
