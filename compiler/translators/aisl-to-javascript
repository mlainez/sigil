#!/usr/bin/env python3
"""
AISL to JavaScript Translator

Translates AISL intermediate representation to JavaScript code.
Usage: aisl-to-javascript input.aisl output.js
"""

import sys
import re
from pathlib import Path

# Type mapping: AISL -> JavaScript (for JSDoc)
TYPE_MAP = {
    'i8': 'number', 'i16': 'number', 'i32': 'number', 'i64': 'number',
    'u8': 'number', 'u16': 'number', 'u32': 'number', 'u64': 'number',
    'f32': 'number', 'f64': 'number',
    'string': 'string',
    'bool': 'boolean',
    'unit': 'void',
    'array': 'Array',
    'map': 'Map',
    'json': 'Object',
}

# Operation mapping: AISL builtins -> JavaScript
OP_MAP = {
    'op_add_i32': '+',
    'op_sub_i32': '-',
    'op_mul_i32': '*',
    'op_div_i32': '/',
    'op_mod_i32': '%',
    
    'op_add_i64': '+',
    'op_sub_i64': '-',
    'op_mul_i64': '*',
    'op_div_i64': '/',
    
    'op_add_f32': '+',
    'op_sub_f32': '-',
    'op_mul_f32': '*',
    'op_div_f32': '/',
    
    'op_add_f64': '+',
    'op_sub_f64': '-',
    'op_mul_f64': '*',
    'op_div_f64': '/',
    
    'op_eq_i32': '===',
    'op_ne_i32': '!==',
    'op_lt_i32': '<',
    'op_gt_i32': '>',
    'op_le_i32': '<=',
    'op_ge_i32': '>=',
    
    'str_concat': '+',
    'str_length': 'length',
    
    'io_print_i32': 'console.log',
    'io_print_i64': 'console.log',
    'io_print_f32': 'console.log',
    'io_print_f64': 'console.log',
    'io_print_str': 'console.log',
    'io_print_bool': 'console.log',
    
    'array_new': 'Array',
    'array_push': 'push',
    'array_get': '[]',
    'array_len': 'length',
    
    'map_new': 'Map',
    'map_set': 'set',
    'map_get': 'get',
}

class JavaScriptTranslator:
    def __init__(self):
        self.indent_level = 0
        self.output = []
        
    def indent(self):
        return '  ' * self.indent_level
        
    def emit(self, code):
        self.output.append(self.indent() + code)
        
    def translate_type(self, aisl_type):
        """Convert AISL type to JavaScript type (for JSDoc)"""
        return TYPE_MAP.get(aisl_type, 'any')
        
    def translate_call(self, func_name, args):
        """Translate function call"""
        # Check if it's a builtin operation
        if func_name in OP_MAP:
            op = OP_MAP[func_name]
            
            # Binary operators
            if op in ['+', '-', '*', '/', '%', '===', '!==', '<', '>', '<=', '>=']:
                if len(args) == 2:
                    return f"({args[0]} {op} {args[1]})"
                    
            # Unary/special functions
            if op == 'length' and len(args) == 1:
                return f"{args[0]}.length"
            if op == 'console.log':
                return f"console.log({', '.join(args)})"
            if op == 'Array' and len(args) == 0:
                return "[]"
            if op == 'Map' and len(args) == 0:
                return "new Map()"
            if op == 'push' and len(args) == 2:
                return f"{args[0]}.push({args[1]})"
            if op == '[]' and len(args) == 2:
                return f"{args[0]}[{args[1]}]"
            if op == 'set' and len(args) == 3:
                return f"{args[0]}.set({args[1]}, {args[2]})"
            if op == 'get' and len(args) == 2:
                return f"{args[0]}.get({args[1]})"
                
        # Regular function call
        return f"{func_name}({', '.join(args)})"
        
    def parse_sexpr(self, code):
        """Very simple S-expression parser"""
        # This is a simplified version - in production, use a proper parser
        tokens = re.findall(r'\(|\)|[^\s()]+', code)
        
        def parse_tokens(i):
            if i >= len(tokens):
                return None, i
                
            if tokens[i] == '(':
                result = []
                i += 1
                while i < len(tokens) and tokens[i] != ')':
                    item, i = parse_tokens(i)
                    if item is not None:
                        result.append(item)
                return result, i + 1
            else:
                return tokens[i], i + 1
                
        ast, _ = parse_tokens(0)
        return ast
        
    def translate_expr(self, expr):
        """Translate an expression"""
        if isinstance(expr, str):
            # Literal or variable
            if expr.startswith('"') and expr.endswith('"'):
                return expr  # String literal
            if expr.isdigit() or (expr[0] == '-' and expr[1:].isdigit()):
                return expr  # Number literal
            if expr == 'true':
                return 'true'
            if expr == 'false':
                return 'false'
            return expr  # Variable name
            
        if isinstance(expr, list) and len(expr) > 0:
            op = expr[0]
            
            if op == 'call':
                func = expr[1] if len(expr) > 1 else 'unknown'
                args = [self.translate_expr(e) for e in expr[2:]]
                if isinstance(func, list):
                    func = self.translate_expr(func)
                result = self.translate_call(func, args)
                # Check if it's a statement (console.log, push, etc.)
                if func in ['io_print_i32', 'io_print_i64', 'io_print_f32', 'io_print_f64', 
                           'io_print_str', 'io_print_bool'] or 'push' in result or 'set' in result:
                    self.emit(result + ';')
                    return None
                return result
                
            if op == 'set':
                var_name = expr[1]
                var_type = expr[2]
                value = self.translate_expr(expr[3]) if len(expr) > 3 else 'undefined'
                self.emit(f"let {var_name} = {value};")
                return None
                
            if op == 'ret':
                if len(expr) > 1:
                    value = self.translate_expr(expr[1])
                    self.emit(f"return {value};")
                else:
                    self.emit("return;")
                return None
                
            if op == 'if':
                cond = self.translate_expr(expr[1])
                self.emit(f"if ({cond}) {{")
                self.indent_level += 1
                then_expr = expr[2]
                self.translate_expr(then_expr)
                self.indent_level -= 1
                if len(expr) > 3:
                    self.emit("} else {")
                    self.indent_level += 1
                    else_expr = expr[3]
                    self.translate_expr(else_expr)
                    self.indent_level -= 1
                self.emit("}")
                return None
                
        return "undefined"
        
    def translate_function(self, func_def):
        """Translate a function definition"""
        # (fn name ((param1 type1) (param2 type2)) -> return_type body)
        func_name = func_def[1]
        params = func_def[2] if len(func_def) > 2 else []
        return_type = 'void'
        body_start = 3
        
        # Check for return type (-> type)
        if len(func_def) > body_start and func_def[body_start] == '->':
            return_type = func_def[body_start + 1]
            body_start = body_start + 2
            
        # Build parameter list
        js_params = []
        param_docs = []
        if isinstance(params, list):
            for param in params:
                if isinstance(param, list) and len(param) >= 2:
                    param_name = param[0]
                    param_type = self.translate_type(param[1])
                    js_params.append(param_name)
                    param_docs.append(f" * @param {{{param_type}}} {param_name}")
                    
        # Generate JSDoc
        self.emit("/**")
        for doc in param_docs:
            self.emit(doc)
        js_return = self.translate_type(return_type)
        self.emit(f" * @returns {{{js_return}}}")
        self.emit(" */")
        
        # Generate function signature
        params_str = ', '.join(js_params)
        self.emit(f"function {func_name}({params_str}) {{")
        self.indent_level += 1
        
        # Translate body
        for i in range(body_start, len(func_def)):
            self.translate_expr(func_def[i])
            
        self.indent_level -= 1
        self.emit("}")
        self.emit("")  # Blank line after function
        
    def translate_module(self, module):
        """Translate a module"""
        # Add header
        self.emit("// Generated by AISL to JavaScript translator")
        self.emit('"use strict";')
        self.emit("")
        
        # (mod name definitions...)
        for i in range(2, len(module)):
            item = module[i]
            if isinstance(item, list) and len(item) > 0:
                if item[0] == 'fn':
                    self.translate_function(item)
                    
        return '\n'.join(self.output)

def main():
    if len(sys.argv) != 3:
        print("Usage: aisl-to-javascript input.aisl output.js")
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    # Read AISL code
    try:
        with open(input_file, 'r') as f:
            aisl_code = f.read()
    except Exception as e:
        print(f"Error reading {input_file}: {e}")
        sys.exit(1)
        
    # Parse and translate
    translator = JavaScriptTranslator()
    ast = translator.parse_sexpr(aisl_code)
    
    if ast and isinstance(ast, list) and ast[0] == 'mod':
        js_code = translator.translate_module(ast)
        
        # Write JavaScript code
        try:
            with open(output_file, 'w') as f:
                f.write(js_code)
            print(f"Translated {input_file} -> {output_file}")
        except Exception as e:
            print(f"Error writing {output_file}: {e}")
            sys.exit(1)
    else:
        print("Error: Invalid AISL module format")
        sys.exit(1)

if __name__ == '__main__':
    main()
