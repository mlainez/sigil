#!/usr/bin/env python3
"""
AISL to Elixir Translator

Translates AISL intermediate representation to Elixir code.
Usage: aisl-to-elixir input.aisl output.ex
"""

import sys
import re
from pathlib import Path

# Type mapping: AISL -> Elixir (for typespecs)
TYPE_MAP = {
    'i8': 'integer()', 'i16': 'integer()', 'i32': 'integer()', 'i64': 'integer()',
    'u8': 'integer()', 'u16': 'integer()', 'u32': 'integer()', 'u64': 'integer()',
    'f32': 'float()', 'f64': 'float()',
    'string': 'String.t()',
    'bool': 'boolean()',
    'unit': 'nil',
    'array': 'list()',
    'map': 'map()',
    'json': 'map()',
}

# Operation mapping: AISL builtins -> Elixir
OP_MAP = {
    'op_add_i32': '+',
    'op_sub_i32': '-',
    'op_mul_i32': '*',
    'op_div_i32': 'div',
    'op_mod_i32': 'rem',
    
    'op_add_i64': '+',
    'op_sub_i64': '-',
    'op_mul_i64': '*',
    'op_div_i64': 'div',
    
    'op_add_f32': '+',
    'op_sub_f32': '-',
    'op_mul_f32': '*',
    'op_div_f32': '/',
    
    'op_add_f64': '+',
    'op_sub_f64': '-',
    'op_mul_f64': '*',
    'op_div_f64': '/',
    
    'op_eq_i32': '==',
    'op_ne_i32': '!=',
    'op_lt_i32': '<',
    'op_gt_i32': '>',
    'op_le_i32': '<=',
    'op_ge_i32': '>=',
    
    'str_concat': '<>',
    'str_length': 'String.length',
    
    'io_print_i32': 'IO.puts',
    'io_print_i64': 'IO.puts',
    'io_print_f32': 'IO.puts',
    'io_print_f64': 'IO.puts',
    'io_print_str': 'IO.puts',
    'io_print_bool': 'IO.puts',
    
    'array_new': '[]',
    'array_push': '++',
    'array_get': 'Enum.at',
    'array_len': 'length',
    
    'map_new': '%{}',
    'map_set': 'Map.put',
    'map_get': 'Map.get',
}

class ElixirTranslator:
    def __init__(self):
        self.indent_level = 0
        self.output = []
        self.module_name = "AislModule"
        
    def indent(self):
        return '  ' * self.indent_level
        
    def emit(self, code):
        self.output.append(self.indent() + code)
        
    def translate_type(self, aisl_type):
        """Convert AISL type to Elixir typespec"""
        return TYPE_MAP.get(aisl_type, 'any()')
        
    def translate_call(self, func_name, args):
        """Translate function call"""
        # Check if it's a builtin operation
        if func_name in OP_MAP:
            op = OP_MAP[func_name]
            
            # Binary operators
            if op in ['+', '-', '*', '/', '==', '!=', '<', '>', '<=', '>=', '<>']:
                if len(args) == 2:
                    return f"({args[0]} {op} {args[1]})"
            
            # Integer division
            if op in ['div', 'rem'] and len(args) == 2:
                return f"{op}({args[0]}, {args[1]})"
                    
            # Unary/special functions
            if op == 'String.length' and len(args) == 1:
                return f"String.length({args[0]})"
            if op == 'IO.puts':
                return f"IO.puts({', '.join(args)})"
            if op == '[]' and len(args) == 0:
                return "[]"
            if op == '%{}' and len(args) == 0:
                return "%{}"
            if op == 'length' and len(args) == 1:
                return f"length({args[0]})"
            if op == '++' and len(args) == 2:
                return f"({args[0]} ++ [{args[1]}])"
            if op == 'Enum.at' and len(args) == 2:
                return f"Enum.at({args[0]}, {args[1]})"
            if op == 'Map.get' and len(args) >= 2:
                return f"Map.get({', '.join(args)})"
            if op == 'Map.put' and len(args) == 3:
                return f"Map.put({args[0]}, {args[1]}, {args[2]})"
                
        # Regular function call
        return f"{func_name}({', '.join(args)})"
        
    def parse_sexpr(self, code):
        """Very simple S-expression parser"""
        # This is a simplified version - in production, use a proper parser
        tokens = re.findall(r'\(|\)|[^\s()]+', code)
        
        def parse_tokens(i):
            if i >= len(tokens):
                return None, i
                
            if tokens[i] == '(':
                result = []
                i += 1
                while i < len(tokens) and tokens[i] != ')':
                    item, i = parse_tokens(i)
                    if item is not None:
                        result.append(item)
                return result, i + 1
            else:
                return tokens[i], i + 1
                
        ast, _ = parse_tokens(0)
        return ast
        
    def translate_expr(self, expr, is_last=False):
        """Translate an expression"""
        if isinstance(expr, str):
            # Literal or variable
            if expr.startswith('"') and expr.endswith('"'):
                return expr  # String literal
            if expr.isdigit() or (expr[0] == '-' and expr[1:].isdigit()):
                return expr  # Number literal
            if expr == 'true':
                return 'true'
            if expr == 'false':
                return 'false'
            return expr  # Variable name
            
        if isinstance(expr, list) and len(expr) > 0:
            op = expr[0]
            
            if op == 'call':
                func = expr[1] if len(expr) > 1 else 'unknown'
                args = [self.translate_expr(e) for e in expr[2:]]
                if isinstance(func, list):
                    func = self.translate_expr(func)
                result = self.translate_call(func, args)
                # In Elixir, if this is not a return statement, emit it
                if not is_last:
                    self.emit(result)
                    return None
                return result
                
            if op == 'set':
                var_name = expr[1]
                var_type = expr[2]
                value = self.translate_expr(expr[3]) if len(expr) > 3 else 'nil'
                self.emit(f"{var_name} = {value}")
                return None
                
            if op == 'ret':
                if len(expr) > 1:
                    value = self.translate_expr(expr[1])
                    # In Elixir, just return the value (implicit return)
                    self.emit(value)
                else:
                    self.emit("nil")
                return None
                
            if op == 'if':
                cond = self.translate_expr(expr[1])
                self.emit(f"if {cond} do")
                self.indent_level += 1
                then_expr = expr[2]
                self.translate_expr(then_expr, is_last=True)
                self.indent_level -= 1
                if len(expr) > 3:
                    self.emit("else")
                    self.indent_level += 1
                    else_expr = expr[3]
                    self.translate_expr(else_expr, is_last=True)
                    self.indent_level -= 1
                self.emit("end")
                return None
                
        return "nil"
        
    def translate_function(self, func_def):
        """Translate a function definition"""
        # (fn name ((param1 type1) (param2 type2)) -> return_type body)
        func_name = func_def[1]
        params = func_def[2] if len(func_def) > 2 else []
        return_type = 'nil'
        body_start = 3
        
        # Check for return type (-> type)
        if len(func_def) > body_start and func_def[body_start] == '->':
            return_type = func_def[body_start + 1]
            body_start = body_start + 2
            
        # Build parameter list
        ex_params = []
        param_types = []
        if isinstance(params, list):
            for param in params:
                if isinstance(param, list) and len(param) >= 2:
                    param_name = param[0]
                    param_type = self.translate_type(param[1])
                    ex_params.append(param_name)
                    param_types.append(param_type)
                    
        # Generate typespec
        ex_return = self.translate_type(return_type)
        typespec_params = ', '.join(param_types) if param_types else ''
        self.emit(f"@spec {func_name}({typespec_params}) :: {ex_return}")
        
        # Generate function signature
        params_str = ', '.join(ex_params)
        self.emit(f"def {func_name}({params_str}) do")
        self.indent_level += 1
        
        # Translate body
        body_exprs = func_def[body_start:]
        for i, body_expr in enumerate(body_exprs):
            is_last = (i == len(body_exprs) - 1)
            self.translate_expr(body_expr, is_last=is_last)
            
        self.indent_level -= 1
        self.emit("end")
        self.emit("")  # Blank line after function
        
    def translate_module(self, module):
        """Translate a module"""
        # Extract module name
        if len(module) > 1:
            self.module_name = module[1].capitalize()
            
        # Add header
        self.emit("# Generated by AISL to Elixir translator")
        self.emit(f"defmodule {self.module_name} do")
        self.indent_level += 1
        self.emit("")
        
        # (mod name definitions...)
        for i in range(2, len(module)):
            item = module[i]
            if isinstance(item, list) and len(item) > 0:
                if item[0] == 'fn':
                    self.translate_function(item)
        
        self.indent_level -= 1            
        self.emit("end")
                    
        return '\n'.join(self.output)

def main():
    if len(sys.argv) != 3:
        print("Usage: aisl-to-elixir input.aisl output.ex")
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    # Read AISL code
    try:
        with open(input_file, 'r') as f:
            aisl_code = f.read()
    except Exception as e:
        print(f"Error reading {input_file}: {e}")
        sys.exit(1)
        
    # Parse and translate
    translator = ElixirTranslator()
    ast = translator.parse_sexpr(aisl_code)
    
    if ast and isinstance(ast, list) and ast[0] == 'mod':
        elixir_code = translator.translate_module(ast)
        
        # Write Elixir code
        try:
            with open(output_file, 'w') as f:
                f.write(elixir_code)
            print(f"Translated {input_file} -> {output_file}")
        except Exception as e:
            print(f"Error writing {output_file}: {e}")
            sys.exit(1)
    else:
        print("Error: Invalid AISL module format")
        sys.exit(1)

if __name__ == '__main__':
    main()
