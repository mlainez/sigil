#!/usr/bin/env python3
"""
AISL to TypeScript Translator
Usage: aisl-to-typescript input.aisl output.ts
"""
import sys, re

TYPE_MAP = {
    'i8': 'number', 'i16': 'number', 'i32': 'number', 'i64': 'number',
    'u8': 'number', 'u16': 'number', 'u32': 'number', 'u64': 'number',
    'f32': 'number', 'f64': 'number',
    'string': 'string', 'bool': 'boolean', 'unit': 'void',
    'array': 'Array', 'map': 'Map', 'json': 'any',
}

OP_MAP = {
    'op_add_i32': '+', 'op_sub_i32': '-', 'op_mul_i32': '*', 'op_div_i32': '/',
    'op_add_i64': '+', 'op_add_f32': '+', 'op_add_f64': '+',
    'str_concat': '+', 'str_length': '.length',
    'io_print_i32': 'console.log', 'io_print_str': 'console.log',
    'array_new': '[]', 'map_new': 'new Map()',
}

class TSTranslator:
    def __init__(self):
        self.indent_level, self.output = 0, []
    
    def indent(self):
        return '  ' * self.indent_level
    
    def emit(self, code):
        self.output.append(self.indent() + code)
    
    def translate_type(self, t):
        return TYPE_MAP.get(t, 'any')
    
    def translate_call(self, func, args):
        if func in OP_MAP:
            op = OP_MAP[func]
            if op in ['+', '-', '*', '/'] and len(args) == 2:
                return f"({args[0]} {op} {args[1]})"
            if func == 'str_length' and len(args) == 1:
                return f"{args[0]}.length"
            if func.startswith('io_print'):
                return f"console.log({', '.join(args)})"
            if op == '[]':
                return "[]"
        return f"{func}({', '.join(args)})"
    
    def parse_sexpr(self, code):
        tokens = re.findall(r'\(|\)|[^\s()]+', code)
        def parse(i):
            if i >= len(tokens): return None, i
            if tokens[i] == '(':
                result, i = [], i + 1
                while i < len(tokens) and tokens[i] != ')':
                    item, i = parse(i)
                    if item is not None: result.append(item)
                return result, i + 1
            return tokens[i], i + 1
        ast, _ = parse(0)
        return ast
    
    def translate_expr(self, expr):
        if isinstance(expr, str):
            if expr in ['true', 'false']: return expr
            return expr
        if isinstance(expr, list) and len(expr) > 0:
            op = expr[0]
            if op == 'call':
                func = expr[1] if len(expr) > 1 else 'unknown'
                args = [self.translate_expr(e) for e in expr[2:]]
                if isinstance(func, list): func = self.translate_expr(func)
                return self.translate_call(func, args)
            if op == 'set':
                var_name, var_type = expr[1], expr[2]
                value = self.translate_expr(expr[3]) if len(expr) > 3 else 'null'
                ts_type = self.translate_type(var_type)
                self.emit(f"let {var_name}: {ts_type} = {value};")
                return None
            if op == 'ret':
                if len(expr) > 1:
                    value = self.translate_expr(expr[1])
                    self.emit(f"return {value};")
                else:
                    self.emit("return;")
                return None
        return "null"
    
    def translate_function(self, func_def):
        func_name, params = func_def[1], func_def[2] if len(func_def) > 2 else []
        return_type, body_start = 'void', 3
        if len(func_def) > body_start and func_def[body_start] == '->':
            return_type, body_start = func_def[body_start + 1], body_start + 2
        
        ts_params = []
        if isinstance(params, list):
            for p in params:
                if isinstance(p, list) and len(p) >= 2:
                    ts_params.append(f"{p[0]}: {self.translate_type(p[1])}")
        
        ts_return = self.translate_type(return_type)
        self.emit(f"function {func_name}({', '.join(ts_params)}): {ts_return} {{")
        self.indent_level += 1
        for i in range(body_start, len(func_def)):
            self.translate_expr(func_def[i])
        self.indent_level -= 1
        self.emit("}\n")
    
    def translate_module(self, module):
        self.emit("// Generated by AISL to TypeScript translator\n")
        for i in range(2, len(module)):
            item = module[i]
            if isinstance(item, list) and len(item) > 0 and item[0] == 'fn':
                self.translate_function(item)
        return '\n'.join(self.output)

def main():
    if len(sys.argv) != 3:
        print("Usage: aisl-to-typescript input.aisl output.ts")
        sys.exit(1)
    
    input_file, output_file = sys.argv[1], sys.argv[2]
    try:
        with open(input_file, 'r') as f:
            aisl_code = f.read()
    except Exception as e:
        print(f"Error reading {input_file}: {e}")
        sys.exit(1)
    
    translator = TSTranslator()
    ast = translator.parse_sexpr(aisl_code)
    
    if ast and isinstance(ast, list) and ast[0] == 'mod':
        ts_code = translator.translate_module(ast)
        try:
            with open(output_file, 'w') as f:
                f.write(ts_code)
            print(f"Translated {input_file} -> {output_file}")
        except Exception as e:
            print(f"Error writing {output_file}: {e}")
            sys.exit(1)
    else:
        print("Error: Invalid AISL module format")
        sys.exit(1)

if __name__ == '__main__':
    main()
