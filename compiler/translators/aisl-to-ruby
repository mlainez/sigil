#!/usr/bin/env python3
"""
AISL to Ruby Translator

Translates AISL intermediate representation to Ruby code.
Usage: aisl-to-ruby input.aisl output.rb
"""

import sys
import re
from pathlib import Path

# Type mapping: AISL -> Ruby (Ruby is dynamically typed, these are for comments)
TYPE_MAP = {
    'i8': 'Integer', 'i16': 'Integer', 'i32': 'Integer', 'i64': 'Integer',
    'u8': 'Integer', 'u16': 'Integer', 'u32': 'Integer', 'u64': 'Integer',
    'f32': 'Float', 'f64': 'Float',
    'string': 'String',
    'bool': 'Boolean',
    'unit': 'nil',
    'array': 'Array',
    'map': 'Hash',
    'json': 'Hash',
}

# Operation mapping: AISL builtins -> Ruby
OP_MAP = {
    'op_add_i32': '+',
    'op_sub_i32': '-',
    'op_mul_i32': '*',
    'op_div_i32': '/',
    'op_mod_i32': '%',
    
    'op_add_i64': '+',
    'op_sub_i64': '-',
    'op_mul_i64': '*',
    'op_div_i64': '/',
    
    'op_add_f32': '+',
    'op_sub_f32': '-',
    'op_mul_f32': '*',
    'op_div_f32': '/',
    
    'op_add_f64': '+',
    'op_sub_f64': '-',
    'op_mul_f64': '*',
    'op_div_f64': '/',
    
    'op_eq_i32': '==',
    'op_ne_i32': '!=',
    'op_lt_i32': '<',
    'op_gt_i32': '>',
    'op_le_i32': '<=',
    'op_ge_i32': '>=',
    
    'str_concat': '+',
    'str_length': 'length',
    
    'io_print_i32': 'puts',
    'io_print_i64': 'puts',
    'io_print_f32': 'puts',
    'io_print_f64': 'puts',
    'io_print_str': 'puts',
    'io_print_bool': 'puts',
    
    'array_new': 'Array.new',
    'array_push': 'push',
    'array_get': '[]',
    'array_len': 'length',
    
    'map_new': 'Hash.new',
    'map_set': '[]=',
    'map_get': '[]',
}

class RubyTranslator:
    def __init__(self):
        self.indent_level = 0
        self.output = []
        
    def indent(self):
        return '  ' * self.indent_level
        
    def emit(self, code):
        self.output.append(self.indent() + code)
        
    def translate_type(self, aisl_type):
        """Convert AISL type to Ruby type (for documentation)"""
        return TYPE_MAP.get(aisl_type, 'Object')
        
    def translate_call(self, func_name, args):
        """Translate function call"""
        # Check if it's a builtin operation
        if func_name in OP_MAP:
            op = OP_MAP[func_name]
            
            # Binary operators
            if op in ['+', '-', '*', '/', '%', '==', '!=', '<', '>', '<=', '>=']:
                if len(args) == 2:
                    return f"({args[0]} {op} {args[1]})"
                    
            # Unary/special functions
            if op == 'length' and len(args) == 1:
                return f"{args[0]}.length"
            if op == 'puts':
                return f"puts {', '.join(args)}"
            if op == 'Array.new' and len(args) == 0:
                return "[]"
            if op == 'Hash.new' and len(args) == 0:
                return "{}"
            if op == 'push' and len(args) == 2:
                return f"{args[0]}.push({args[1]})"
            if op == '[]' and len(args) == 2:
                return f"{args[0]}[{args[1]}]"
            if op == '[]=' and len(args) == 3:
                return f"{args[0]}[{args[1]}] = {args[2]}"
                
        # Regular function call
        return f"{func_name}({', '.join(args)})"
        
    def parse_sexpr(self, code):
        """Very simple S-expression parser"""
        # This is a simplified version - in production, use a proper parser
        tokens = re.findall(r'\(|\)|[^\s()]+', code)
        
        def parse_tokens(i):
            if i >= len(tokens):
                return None, i
                
            if tokens[i] == '(':
                result = []
                i += 1
                while i < len(tokens) and tokens[i] != ')':
                    item, i = parse_tokens(i)
                    if item is not None:
                        result.append(item)
                return result, i + 1
            else:
                return tokens[i], i + 1
                
        ast, _ = parse_tokens(0)
        return ast
        
    def translate_expr(self, expr):
        """Translate an expression"""
        if isinstance(expr, str):
            # Literal or variable
            if expr.startswith('"') and expr.endswith('"'):
                return expr  # String literal
            if expr.isdigit() or (expr[0] == '-' and expr[1:].isdigit()):
                return expr  # Number literal
            if expr == 'true':
                return 'true'
            if expr == 'false':
                return 'false'
            return expr  # Variable name
            
        if isinstance(expr, list) and len(expr) > 0:
            op = expr[0]
            
            if op == 'call':
                func = expr[1] if len(expr) > 1 else 'unknown'
                args = [self.translate_expr(e) for e in expr[2:]]
                if isinstance(func, list):
                    func = self.translate_expr(func)
                return self.translate_call(func, args)
                
            if op == 'set':
                var_name = expr[1]
                var_type = expr[2]
                value = self.translate_expr(expr[3]) if len(expr) > 3 else 'nil'
                self.emit(f"{var_name} = {value}")
                return None
                
            if op == 'ret':
                if len(expr) > 1:
                    value = self.translate_expr(expr[1])
                    self.emit(f"return {value}")
                else:
                    self.emit("return")
                return None
                
            if op == 'if':
                cond = self.translate_expr(expr[1])
                self.emit(f"if {cond}")
                self.indent_level += 1
                then_expr = expr[2]
                self.translate_expr(then_expr)
                self.indent_level -= 1
                if len(expr) > 3:
                    self.emit("else")
                    self.indent_level += 1
                    else_expr = expr[3]
                    self.translate_expr(else_expr)
                    self.indent_level -= 1
                self.emit("end")
                return None
                
        return "nil"
        
    def translate_function(self, func_def):
        """Translate a function definition"""
        # (fn name ((param1 type1) (param2 type2)) -> return_type body)
        func_name = func_def[1]
        params = func_def[2] if len(func_def) > 2 else []
        return_type = 'nil'
        body_start = 3
        
        # Check for return type (-> type)
        if len(func_def) > body_start and func_def[body_start] == '->':
            return_type = func_def[body_start + 1]
            body_start = body_start + 2
            
        # Build parameter list
        rb_params = []
        if isinstance(params, list):
            for param in params:
                if isinstance(param, list) and len(param) >= 2:
                    param_name = param[0]
                    param_type = self.translate_type(param[1])
                    rb_params.append(param_name)
                    
        # Generate function signature
        params_str = ', '.join(rb_params)
        self.emit(f"def {func_name}({params_str})")
        self.indent_level += 1
        
        # Translate body
        for i in range(body_start, len(func_def)):
            self.translate_expr(func_def[i])
            
        self.indent_level -= 1
        self.emit("end")
        self.emit("")  # Blank line after function
        
    def translate_module(self, module):
        """Translate a module"""
        # Add header
        self.emit("# Generated by AISL to Ruby translator")
        self.emit("# frozen_string_literal: true")
        self.emit("")
        
        # (mod name definitions...)
        for i in range(2, len(module)):
            item = module[i]
            if isinstance(item, list) and len(item) > 0:
                if item[0] == 'fn':
                    self.translate_function(item)
                    
        return '\n'.join(self.output)

def main():
    if len(sys.argv) != 3:
        print("Usage: aisl-to-ruby input.aisl output.rb")
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    # Read AISL code
    try:
        with open(input_file, 'r') as f:
            aisl_code = f.read()
    except Exception as e:
        print(f"Error reading {input_file}: {e}")
        sys.exit(1)
        
    # Parse and translate
    translator = RubyTranslator()
    ast = translator.parse_sexpr(aisl_code)
    
    if ast and isinstance(ast, list) and ast[0] == 'mod':
        ruby_code = translator.translate_module(ast)
        
        # Write Ruby code
        try:
            with open(output_file, 'w') as f:
                f.write(ruby_code)
            print(f"Translated {input_file} -> {output_file}")
        except Exception as e:
            print(f"Error writing {output_file}: {e}")
            sys.exit(1)
    else:
        print("Error: Invalid AISL module format")
        sys.exit(1)

if __name__ == '__main__':
    main()
