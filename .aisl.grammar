@(grammar aisl-agent)
@(stat tests:126 examples:17 stdlib:13)
@(syn
  (prog (module name imp* fn*))
  (imp (import name))
  (fn (fn name p* -> ty s*))
  (s (set v ty e) | (f a*) | (ret e) | (while e s*) | (loop s*) | (if e s*) | (break) | (cont))
  (e lit | var | (f a*))
  (lit int | float | str | true | false)
  (ty int|float|decimal|bool|str|arr|map|json|regex|process|socket|file))
@(op
  (arith add sub mul div mod neg abs min max pow sqrt)
  (cmp eq ne lt gt le ge)
  (log and or not)
  (bit shl shr band bor bxor bnot)
  (str concat len equals slice split trim contains replace)
  (regex compile match find find_all replace)
  (arr new push pop get set len slice sort filter map reduce)
  (map new get set has del keys vals len)
  (io print println read_line file_read file_write file_exists stdin_read stdin_read_all)
  (net tcp_listen tcp_accept tcp_send tcp_recv http_get http_post)
  (sys time sleep env exit process_exec)
  (cast int_float float_int int_str str_int int_decimal decimal_int float_decimal decimal_float))
@(ex
  (fn add a int b int -> int (ret (add a b)))
  (fn fact n int -> int 
    (if (eq n 0)
      (ret 1))
    (ret (mul n (fact (sub n 1)))))
    (if (eq n 0)
      (ret 1))
    (ret (mul n (fact (sub n 1)))))
  (fn sum arr arr n int -> int
    (set s int 0)
    (set i int 0)
    (while (lt i n)
      (set s int (add s (array_get arr i)))
      (set i int (add i 1)))
    (ret s)))
@(mod
  (stdlib-modules "13 modules in pure AISL")
  (core "string_utils conversion")
  (data "json base64")
  (net "http websocket")
  (pattern "regex")
  (crypto "hash")
  (sys "time process")
  (db "sqlite")
  (paths "stdlib/core/ stdlib/data/ stdlib/net/ stdlib/sys/ stdlib/crypto/ stdlib/pattern/ stdlib/db/")
  (import-qualified "(import json from data) - NOT SUPPORTED - use (import json_utils)"))
@(note
  (no-comments "AISL does not support comments")
  (explicit-types "all vars must have types")
  (no-implicit-conv "use cast functions")
  (type-dispatch "add -> add_int|add_float auto")
  (simplified-types "only int and float - no sized types")
  (module-keyword "use (module ...) not (mod ...) - mod reserved for modulo")
  (modulo-operation "(mod x y) for modulo")
  (ifnot-core-only "ifnot is Core IR - Agent code uses (if (not condition) body)")
  (agent-vs-core "Agent constructs: if while loop break continue - Core: ifnot goto label set ret")
  (array-new-single-way "CRITICAL: (array_new) takes NO parameters - all arrays are dynamic")
  (array-new-no-capacity "array_new NEVER takes capacity argument - compiler error if provided")
  (array-dynamic-only "Arrays start with capacity 16, double automatically on push when full")
  (one-way-arrays "ONE WAY ONLY: (array_new) - no confusion, no options")
  (test-framework "use test-spec, case, input, expect")
  (regex-builtin "regex type + compile/match/find/replace ops")
  (aisl-only-tooling "NEVER Python/Bash - ALWAYS AISL")
  (reserved-types "NEVER use as var names: decimal json array map int float string bool process socket file")
  (handle-types "process socket file are first-class types - use for DB handles, TCP sockets, files")
  (type-safety "use process for DB handles, socket for TCP, file for files - NO string")
  (sqlite-tcp-works "SQLite + TCP work with proper handle types")
  (reserved-modules "NEVER name modules with type keywords - causes parse errors")
  (entry-point "fn main -> int required - VM errors if missing")
  (if-multi-stmt-bug "CRITICAL BUG: parser treats all stmts after if condition as then-branch - use result var pattern")
  (if-workaround "Store condition in var, use separate if for then/else branches")
  (modules-first "import statement BEFORE fn definitions")
  (module-closing-paren "modules MUST end with ) - missing causes 'Module not found'")
  (stdlib-imports "string ops need (import string_utils) - json needs (import json_utils)")
  (string-slice-params "string_slice takes (str, start, LENGTH) NOT (str, start, end)")
  (reserved-test-keywords "input expect case CANNOT be variable names - reserved by test-spec parser")
  (decimal-type "decimal type for arbitrary precision arithmetic - stored as normalized strings")
  (decimal-precision "15 significant digits via float internally - sufficient for most financial calculations")
  (decimal-operations "all arithmetic + comparisons work: add sub mul div neg eq ne lt gt le ge")
  (decimal-conversions "cast_int_decimal cast_decimal_int cast_float_decimal cast_decimal_float")
  (decimal-normalized "decimals stored as normalized strings: '123.456' '-0.5' '42' '0.3'")
  (decimal-advantage "0.1 + 0.2 = 0.3 (not 0.30000000000000004 like float)"))